<!DOCTYPE html>
<html>
<head>
<title>Faces</title>
<style>
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
}
canvas {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
  background: black;
}
</style>
</head>

<body></body>
</html>

<script src='https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.4/p5.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js'></script>
<script type='text/javascript'>

var pageWidth = jQuery('body').width();
var pageHeight = jQuery('body').height();

var face = {}; // Namespace
face.width = 7 * 210, face.height = 7 * 297;
face.xC = face.width / 2, face.yC = face.height / 2;
face.universe = [];

face.Particle = function(xStart, yStart, xSpeed, ySpeed) {
	// Coordinates inside the img space
	this.x = xStart;
	this.y = yStart;
	this.xSpeed = xSpeed;
	this.ySpeed = ySpeed;
	this.r = Math.random() * Math.sqrt(pageWidth/2 * pageWidth/2 + pageHeight/2 * pageHeight/2);
	this.theta = Math.random() * 2 * Math.PI;
	this.rSpeed = 0.01;
	this.thetaSpeed = 0.01;

	this.move = function() {
		// Acceleration based on gray level (i.e. red here) gradient
		// Gradient based on minimal grey value (draw black in darkest places)
		
		var acc = 0.05; // * (-255/2 + face.pixelRGBA(Math.floor(this.x), Math.floor(this.y), this).R);
		
		var addedChaos = 10 * (2 * Math.random() - 1);
		var cheat = 0 * Math.random();
		var gradSquare = [
			{ pixel: 'topleft', greyLevel: face.pixelRGBA(Math.floor(this.x - 1), Math.floor(this.y - 1), this).R + addedChaos },
			{ pixel: 'top', greyLevel: face.pixelRGBA(Math.floor(this.x), Math.floor(this.y - 1), this).R + addedChaos },
			{ pixel: 'topright', greyLevel: face.pixelRGBA(Math.floor(this.x + 1), Math.floor(this.y - 1), this).R + addedChaos },
			
			{ pixel: 'left', greyLevel: face.pixelRGBA(Math.floor(this.x - 1), Math.floor(this.y), this).R + addedChaos },
			{ pixel: 'right', greyLevel: face.pixelRGBA(Math.floor(this.x + 1), Math.floor(this.y), this).R + addedChaos },
			
			{ pixel: 'bottomleft', greyLevel: face.pixelRGBA(Math.floor(this.x - 1), Math.floor(this.y + 1), this).R + addedChaos - cheat },
			{ pixel: 'bottom', greyLevel: face.pixelRGBA(Math.floor(this.x), Math.floor(this.y + 1), this).R + addedChaos },
			{ pixel: 'bottomright', greyLevel: face.pixelRGBA(Math.floor(this.x + 1), Math.floor(this.y + 1), this).R + addedChaos }
		];
		
		// Get object with the lowest grey level
		var winner = _.min(gradSquare, function(el) {
			return el.greyLevel;
		});
		// Get object with the highest grey level, to check if all have the same value
		var loser = _.max(gradSquare, function(el) {
			return el.greyLevel;
		});
		
		// Do nothing if all surrounding pixels have the same value
		if (winner.greyLevel !== loser.greyLevel) {
			switch(loser.pixel) {
				case 'topleft':
					this.xSpeed -= acc / Math.sqrt(2);
					this.ySpeed -= acc / Math.sqrt(2);
					break;
				case 'top':
					this.ySpeed -= acc;
					break;
				case 'topright':
					this.xSpeed += acc / Math.sqrt(2);
					this.ySpeed -= acc / Math.sqrt(2);
					break;
					
				case 'left':
					this.xSpeed -= acc;
					break;
				case 'right':
					this.xSpeed += acc;
					break;
					
				case 'bottomleft':
					this.xSpeed -= acc / Math.sqrt(2);
					this.ySpeed += acc / Math.sqrt(2);
					break;
				case 'bottom':
					this.ySpeed += acc;
					break;
				case 'bottomright':
					this.xSpeed += acc / Math.sqrt(2);
					this.ySpeed += acc / Math.sqrt(2);
					break;
					
				default:
					(function() {return null;})();
			}
		}
		
		// Speed calmers
		var maxSpeed = 50, minSpeed = 1;
		var speed = Math.sqrt(Math.pow(this.xSpeed, 2) + Math.pow(this.ySpeed, 2));
		if (speed > maxSpeed) {
			this.xSpeed *= maxSpeed / speed;
			this.ySpeed *= maxSpeed / speed;
		}
		if (speed < minSpeed) {
			this.xSpeed *= minSpeed / speed;
			this.ySpeed *= minSpeed / speed;
		}
		
		
		if (this.isOutsideScope()) {
			// Spring attraction to attract maintain particles to the center
			var k = 0.0001;
			var springAccX = -k * (this.x - face.width / 2);
			var springAccY = -k * (this.y - face.height / 2);
			this.xSpeed += springAccX;
			this.ySpeed += springAccY;
		}
		
		this.x += 0.1 * this.xSpeed;
		this.y += 0.1 * this.ySpeed;
		
		// Now update x and y accordingly!
		/*var imgXY = face.polarToXY(this.r, this.theta);
		this.x = imgXY.x;
		this.y = imgXY.y;*/
		
	};

	this.draw = function() {
		var opa = 0.1;
		if (face.pixelRGBA(Math.floor(this.x), Math.floor(this.y), this).R < 133) {
			opa /= 2;
		}
		stroke(color('rgba(255, 255, 255, '+ opa + ')'));
		var canvasXY = face.localImgToCanvas(this.x, this.y);
		point(canvasXY.x, canvasXY.y);
	};
	
	this.isOutsideScope = function() {
		if (this.x < 0 || this.x > face.width || this.y < 0 || this.y > face.height)  { return true; } else { return false; }
	};
}

function preload() {
	// load image
	face.faceImg = loadImage("seb7.bmp", function() {
		console.log('win');
	}, function() {
		console.log('fail');
	});
}

function setup() {
	createCanvas(pageWidth, pageHeight);

	// Resize image
	face.faceImg.resize(face.width, face.height);

	// Filter it
	face.faceImg.filter('gray');
	face.faceImg.loadPixels();

	// Draw it?
	//image(face.faceImg);
	//image(face.faceImg, 0.5 * pageWidth - 0.5 * face.width, 0.5 * pageHeight - 0.5 * face.height);
}

function draw() {
	face.moveParticles();
	face.particleBirth();
	face.drawParticles();
}

face.particleBirth = function() {
	var type = 1 + Math.floor(Math.random() * 6);
	var xStart, yStart, xSpeed, ySpeed, angle, speed;
	
	/* // In Fleur hair 
	// Launch position
	xStart = face.width * 0.6;
	yStart = face.height * 0.13;
	
	// Launch speed and angle
	var angle = 2 * Math.PI * Math.random();
	var speed = 3;
	xSpeed = speed * Math.cos(angle);
	ySpeed = speed * Math.sin(angle);
	*/
	
	/*
	// Wind in da face
	xStart = face.width * 0.87;
	yStart = face.height * 0.3 * Math.random();
	// Launch speed and angle
	var angle = -1.1 * Math.PI;
	var speed = 10;
	xSpeed = speed * Math.cos(angle);
	ySpeed = speed * Math.sin(angle);
	*/
	
	/*
	// Everywhere
	xStart = face.width * Math.random();
	yStart = face.height * Math.random();
	var angle = 2 * Math.PI * Math.random();
	var speed = 1;
	xSpeed = speed * Math.cos(angle);
	ySpeed = speed * Math.sin(angle);
	*/
	
	var speed = 2;
	
	if (type == '1') {
		// Top side
		xStart = face.width * Math.random();
		yStart = 0;
		angle = 1/2 * Math.PI;
	} else if (type == '2') {
		// Right side
		xStart = face.width;
		yStart = face.height * Math.random();
		angle = Math.PI;
	} else if (type == '3') {
		// Bottom side
		xStart = face.width * Math.random();
		yStart = face.height;
		angle = - 1/2 * Math.PI;
	} else if (type == '4') {
		// Left side
		xStart = 0;
		yStart = face.height * Math.random();
		angle = 0;
	} else if (type == '5') {
		// Everywhere
		xStart = face.width * Math.random();
		yStart = face.height * Math.random();
		angle = 2 * Math.PI * Math.random();
		speed = 5;
	} else if (type == '6') {
		// Seb eyes
		if (Math.random() < 0.5) {
			xStart = face.width * 0.381;
			yStart = face.height * 0.466;
			angle = 2 * Math.PI * Math.random();
		} else {
			xStart = face.width * 0.61;
			yStart = face.height * 0.468;
			angle = 2 * Math.PI * Math.random();
		}
		
	}
	
	var extraAngle = (2 * Math.random() - 1) * Math.PI / 4;
	xSpeed = speed * Math.cos(angle + extraAngle);
	ySpeed = speed * Math.sin(angle + extraAngle);
	
	face.universe.push(new face.Particle(xStart, yStart, xSpeed, ySpeed));
}
face.moveParticles = function() {
	jQuery(face.universe).each(function() {
		this.move();
	});
}
face.drawParticles = function() {
	jQuery(face.universe).each(function() {
		this.draw();
	});
}
face.pixelRGBA = function(x, y, _this) {
	
	if (_this.isOutsideScope()) {
		return {
			R: 255,
			G: 255,
			B: 255,
			A: 255
		};
	}
    // loop over
    var idx = 4 * (y * face.width + x);
    var R = face.faceImg.pixels[idx];
    var G = face.faceImg.pixels[idx+1];
    var B = face.faceImg.pixels[idx+2];
    var A = face.faceImg.pixels[idx+3];
	
    return {
		R: R,
		G: G,
		B: B,
		A: A
	}
}
face.polarToXY = function(r, theta) {
	var xImg = face.width/2 + r * Math.cos(theta);
    var yImg = face.height/2 - r * Math.sin(-theta);
    return {
      x: xImg,
      y: yImg
    };
}
face.localImgToCanvas = function(xImg, yImg) {
	// From local polar image space to global cartesian canvas space
    var xCanvas = xImg - face.width/2 + pageWidth/2;
    var yCanvas = yImg - face.height/2 + pageHeight/2;
    return {
      x: xCanvas,
      y: yCanvas
    };
}

</script>